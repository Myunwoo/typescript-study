# 2장 타입스크립트의 타입 시스템

## 편집기를 사용하여 타입 시스템 탐색하기

타입스크립트를 설치하면, 다음 두 가지를 실행할 수 있습니다.

- 타입스크립트 컴파일러(tsc)
- 단독으로 실행할 수 있는 타입스크립트 서버(tsserver)

타입스크립트를 사용하는 주된 목적을 타입스크립트 컴파일러를 실행하는 것이지만, 타입스크립트가 '언어 서비스'를 제공한다는 점도 중요합니다. 타입스크립트 서버는 코드 자동 완성, 명세 검사, 검색, 리팩터링 기능을 가지고 있습니다. 보통 IDE를 통한 언어 서비스를 주로 사용하게 되는데, 타입스크립트 서버의 기능도 유용하니 공부해 보겠습니다.

IDE 별로 약간의 차이가 존재하지만 보통 심볼 위에 마우스 커서를 대면 타입스크립트가 해당 심볼의 타입을 어떻게 추론하고 있는지 표시됩니다. 타입스크립트가 추론한 타입과 실제 의도와 다른지 검토하는 과정은 타입 시스템을 연마하는 좋은 방법입니다.

아래 코드를 살펴보겠습니다.
```
function getElement(elOrId: string|HTMLElement|null) : HTMLElement {
    if (typeof elOrId === 'object') {
        return elOrId;
    } else if (elOrId === null) {
        return document.body;
    } else {
        const el = document.getElementById(elOrId);
        return el;
    }
}
```

타입 스크립트에 의해 아래 케이스에서 오류가 발생합니다.

- typeof elOrId === 'object' 분기에서 elOrId를 반환하는 경우
    - 자바스크립트에서 null 또한 object 타입이기 때문에 오류
- const el = document.getElementById(elOrId);
        return el;
    - document.getElementById의 반환 타입에 null이 포함되기 때문에 오류

## 타입이 값들의 집합이라고 생각하기

타입스크립트에서 변수들을 타입을 가지고 있고, 이때의 타입은 '할당 가능한 값들의 집합'이라고 표현할 수 있습니다.
예를 들어, 모든 숫자값의 집합을 number 타입이라고 생각할 수 있습니다.

```
type A = 'A'
type Twelve = 12
```
위처럼, 한 가지 값만 포함하는 '유닛' 혹은 '리터럴' 타입도 정의할 수 있습니다.

```
type AB = 'A' | 'B'
```
혹은 위처럼 타입을 묶어 '유니온' 타입을 만들 수도 있고, 이 경우 '할당 가능한 값들의 집합'의 '합집합'으로 사용하면 됩니다.

```
interface Person {
    name: string;
}

interface Lifespan {
    birth: Date;
    death: Data;
}

type PersonSpan = Person & Lifespan;
```
& 연산자는 두 타입의 교집합을 계산합니다. Person과 Lifespan 인터페이스는 공통으로 가지는 속성이 없기 때문에 PersonSpan 타입을 공집합(never 타입)으로 예상하기 쉬우나, 타입 연산자는 인터페이스의 속성이 아닌, 값의 집합에 적용됩니다. 그리고 추가적인 속성을 가지는 값도 여전히 그 타입에 속합니다. 따라서 PersonSpan은 Person과 Lifespan의 속성을 모두 가지는 타입이 됩니다.

```
cosnt ps: PersonSpan = {
    name: 'Alan Turing',
    birth: new Date('1912/06/23'),
    death: new Date('1954/06/07'),
}; // 정상
```

하지만 좀 더 일반적인 방법으로 PersonSpan을 정의하는 방법은 아래와 같습니다.

```
interface Person {
    name: string;
}

interface PersonSpan extends Person {
    birth: Date;
    death: Date;
}
```

## 타입 공간과 값 공간의 심벌 구분하기

타입스크립트의 심볼은 타입 공간이나 값 공간 중의 한 곳에 존재합니다.

```
interface Cylinder {
    radius: number;
    height: number;
}

const Cylinder = (radius: number, height: number) => ({radius, height});
```

위 코드에서 interface Cylinder는 타입으로, const Cylinder는 값으로 사용되었습니다.

```
function calculateVolume(shape: unknown) {
    if (shape instanceof Cylinder) {
        ...
    }
}
```

따라서 instanceof 뒤의 Cylinder는 값인 Cylinder를 참조하게 됩니다. 타입스크립트에서 값과 타입은 번갈아 등장할 수 있기 때문에, 문맥을 이해하며 제대로 활용해야 합니다.

## 타입 단언보다는 타입 선언을 사용하기

```
interface Person { name: string };

const alice: Person = { name: 'Alice' };
const bob = { name: 'Bob' } as Person;
```

alice는 타입 선언, bob은 타입 단언을 사용한 예시입니다. 두 가지 방법의 결과가 같아 보이지만 그렇지 않습니다.

```
const alice: Person = { };
const bob = { } as Person;
```

위 예시에서 alice는 name 속성이 없다는 에러를 반환하지만, bob은 에러가 발생하지 않습니다. 타입 단언을 사용하는 경우 강제로 타입이 지정되어 타입 체커에게 오류를 무시하라고 하는 것과 같습니다. 이는 alice와 bob 객체에 속성을 추가할 때에도 같은 결과를 보입니다. 따라서 타입 단언이 꼭 필요한 경우가 아니라면, 안전성 체크가 가능한 타입 선언을 사용하는 것이 좋습니다.

화살표 함수의 타입 선언과 추론된 타입에 대해 알아보겠습니다.

```
const people = ['alice', 'bob', 'jan'].map(name => ({name}));
```
위 코드에서 people의 타입이 Person[]이 되기를 원했지만 결과는 { name: string; }[]입니다.

```
const people = ['alice', 'bob', 'jan'].map(name => ({name} as Person));
```
타입 단언을 사용하여 people의 타입을 Person[]으로 만들 수 있지만,

```
const people = ['alice', 'bob', 'jan'].map(name => ({} as Person));
```
이렇게 빈 객체를 반환하게 만드는 코드를 작성하여도 타입 단언 때문에 타입스크립트는 오류를 발생시키지 않습니다.

단언문을 쓰지 않고, 다음과 같이 화살표 함수 안에서 타입과 함께 변수를 선언하는 것이 가장 직관적입니다.

```
const people = ['alice', 'bob', 'jan'].map(name => {
    const person: Person = { name };
    return person;
});
```

하지만 위 코드는 원래 코드에 비해 꽤나 번잡해 보입니다. 코드를 간결하게 하기 위해서 변수 대신 화살표 함수의 반환 타입을 선언하는 방식이 가능합니다.

```
const people = ['alice', 'bob', 'jan'].map((name): Person => ({name}));
```
(name): Person 이라고 작성 함으로써, 각 함수의 반환형이 Person이라고 타입 선언하는 방식입니다.

단, 타입 단언이 유용한 경우가 존재합니다. DOM 엘리먼트에 대해서는 타입스크립트보다 코드의 작성자가 타입을 더 명확하게 알고 있게 됩니다.

```
document.querySelector('#myButton').addEventListener('click', e => {
    const button = e.currentTarget as HTMLButtonElement;
})
```

타입스크립트는 DOM에 접근할 수 없기 때문에 button이 HTMLButtonElement라고 추론할 수 없습니다. 따라서 위 같은 경우에는 타입 단언문을 사용하는 것이 타당합니다.

또한 ! 문법을 사용하는 케이스가 자연스러운 경우도 존재합니다.

```
const el = document.getElementById('foo')!;
```
el의 경우, 타입스크립트는 el의 타입을 HTMLElement | null로 추론합니다.
하지만 DOM의 구조에 대해 알고 있는 사용자는 el이 항상 존재함을 보장해 줄 수 있습니다. 따라서 접미사에 오는 ! 키워드를 사용함으로써 el의 타입을 HTMLElement라고 단언할 수 있습니다.

## 객체 래퍼 타입 피하기

자바스크립트에는 객체 이외에도 기본형 값들에 대한 일곱 가지 타입(string, number, boolean, null, undefined, symbol, bigint)이 있습니다.
기본형들은 불변이며 메서드를 가지지 않는다는 점에서 객체와 구분됩니다.
하지만 이중 string의 경우 메서드를 가지고 있는 것처럼 보입니다.

```
'primitive'.charAt(3) // m
```
하지만 charAt은 string의 메서드가 아니면, String '객체' 타입이 정의되어 있습니다. 자바스크립트는 기본형과 객체 타입을 서로 자유롭게 변환합니다.
그러나 string 기본형과 String 객체 래퍼가 항상 동일하게 동작하는 것은 아닙니다. 예를 들어, String 객체는 오직 자기 자신과만 동일합니다.

```
'hello' === new String('hello') // false
 new String('hello')=== new String('hello') // false
```

래퍼 타입에 속성을 추가하는 경우, 해당 속성이 사라지는 현상도 있습니다.

```
x = 'hello'
x.language = 'English'
x.language // undefined
```
실제로는 x가 String 객체로 변환된 후 language 속성이 추가되었고, 추가된 속성은 바로 버려지게 되는 내부 동작이 발생한 것입니다.

string 외에 다른 기본형에도 동일하게 객체 래퍼 타입이 존재합니다. 하지만 string을 특히 주의해야 하는 이유는 string을 String이라고 잘못 타이핑하기 쉽고, 실수를 하더라도 오류를 찾아내기 어렵기 때문입니다.

## 잉여 속성 체크의 한계 인지하기

타입이 명시된 변수에 객체 리터럴를 할당할 때 타입스크립트는 해당 타입의 속성이 있는지, 그리고 **그 외의 속성은 없는지** 확인합니다.

아래 두 예시를 확인해 보겠습니다.

예시1)
```
interface Room {
    numDoors: number;
    ceilingHeightFt: number;
}

const r: Room = {
    numDoors: 1,
    ceilingHeightFt: 10,
    elephant: 'present', // 에러
}
```

예시2)
```
const obj = {
    numDoors: 1,
    ceilingHeightFt: 10,
    elephant: 'present',
}

const r: Room = obj; // 정상
```

예시1에서는 구조적 타입 시스템에서 발생할 수 있는 중요한 종류의 오류를 잡을 수 있도록 '잉여 속성 체크'라는 과정이 수행되었습니다. 그러나 잉여 속성 체크 역시 조건에 따라 동작하지 않는다는 한계가 있고, 통상적인 할당 가능 검사와 함께 쓰이면 구조적 타이핑이 무엇인지 혼란스러워질 수 있습니다. 잉여 속성 체크가 할당 가능 검사와는 별도의 과정이라는 것을 알아야 합니다.

## 함수 표현식에 타입 적용하기

자바스크립트와 타입스크립트에서는 함수 '문장'과 함수 '표현식'을 다르게 인식합니다.

```
function rollDice1(sides: number): number { ... } // 문장
const rollDice2 = function(side: number): number { ... } // 표현식
const rollDice3 = (side: number): number => { ... } // 표현식
```